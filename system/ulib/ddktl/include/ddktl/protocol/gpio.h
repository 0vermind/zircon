// Copyright 2018 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// WARNING: This file is machine generated by fidlc.

#pragma once

#include <ddk/protocol/gpio.h>
#include <ddktl/device-internal.h>
#include <zircon/assert.h>
#include <zircon/compiler.h>
#include <zircon/types.h>

#include "gpio-internal.h"

// DDK gpio-protocol support
//
// :: Proxies ::
//
// ddk::GpioProtocolProxy is a simple wrapper around
// gpio_protocol_t. It does not own the pointers passed to it
//
// :: Mixins ::
//
// ddk::GpioProtocol is a mixin class that simplifies writing DDK drivers
// that implement the gpio protocol. It doesn't set the base protocol.
//
// :: Examples ::
//
// // A driver that implements a ZX_PROTOCOL_GPIO device.
// class GpioDevice {
// using GpioDeviceType = ddk::Device<GpioDevice, /* ddk mixins */>;
//
// class GpioDevice : public GpioDeviceType,
//                    public ddk::GpioProtocol<GpioDevice> {
//   public:
//     GpioDevice(zx_device_t* parent)
//         : GpioDeviceType("my-gpio-protocol-device", parent) {}
//
//     zx_status_t GpioConfigIn(uint32_t index, uint32_t flags);
//
//     zx_status_t GpioConfigOut(uint32_t index, uint8_t initial_value);
//
//     zx_status_t GpioSetAltFunction(uint32_t index, uint64_t function);
//
//     zx_status_t GpioRead(uint32_t index, uint8_t* out_value);
//
//     zx_status_t GpioWrite(uint32_t index, uint8_t value);
//
//     zx_status_t GpioGetInterrupt(uint32_t index, uint32_t flags, zx_handle_t* out_irq);
//
//     zx_status_t GpioReleaseInterrupt(uint32_t index);
//
//     zx_status_t GpioSetPolarity(uint32_t index, gpio_polarity_t polarity);
//
//     ...
// };

namespace ddk {

// In the functions below, the GPIO index is relative to the list of GPIOs for the device.
// For example, the list of GPIOs a platform device has access to would likely be a small
// subset of the total number of GPIOs, while a platform bus implementation driver would
// have access to the complete set of GPIOs.
template <typename D>
class GpioProtocol : public internal::base_mixin {
public:
    GpioProtocol() {
        internal::CheckGpioProtocolSubclass<D>();
        gpio_protocol_ops_.config_in = GpioConfigIn;
        gpio_protocol_ops_.config_out = GpioConfigOut;
        gpio_protocol_ops_.set_alt_function = GpioSetAltFunction;
        gpio_protocol_ops_.read = GpioRead;
        gpio_protocol_ops_.write = GpioWrite;
        gpio_protocol_ops_.get_interrupt = GpioGetInterrupt;
        gpio_protocol_ops_.release_interrupt = GpioReleaseInterrupt;
        gpio_protocol_ops_.set_polarity = GpioSetPolarity;
    }

protected:
    gpio_protocol_ops_t gpio_protocol_ops_ = {};

private:
    // Configures a GPIO for input.
    static zx_status_t GpioConfigIn(void* ctx, uint32_t index, uint32_t flags) {
        return static_cast<D*>(ctx)->GpioConfigIn(index, flags);
    }
    // Configures a GPIO for output.
    static zx_status_t GpioConfigOut(void* ctx, uint32_t index, uint8_t initial_value) {
        return static_cast<D*>(ctx)->GpioConfigOut(index, initial_value);
    }
    // Configures the GPIO pin for an alternate function (I2C, SPI, etc)
    // the interpretation of "function" is platform dependent.
    static zx_status_t GpioSetAltFunction(void* ctx, uint32_t index, uint64_t function) {
        return static_cast<D*>(ctx)->GpioSetAltFunction(index, function);
    }
    // Reads the current value of a GPIO (0 or 1).
    static zx_status_t GpioRead(void* ctx, uint32_t index, uint8_t* out_value) {
        return static_cast<D*>(ctx)->GpioRead(index, out_value);
    }
    // Sets the current value of the GPIO (any non-zero value maps to 1).
    static zx_status_t GpioWrite(void* ctx, uint32_t index, uint8_t value) {
        return static_cast<D*>(ctx)->GpioWrite(index, value);
    }
    // Gets an interrupt object pertaining to a particular GPIO pin.
    static zx_status_t GpioGetInterrupt(void* ctx, uint32_t index, uint32_t flags,
                                        zx_handle_t* out_irq) {
        return static_cast<D*>(ctx)->GpioGetInterrupt(index, flags, out_irq);
    }
    // Release the interrupt.
    static zx_status_t GpioReleaseInterrupt(void* ctx, uint32_t index) {
        return static_cast<D*>(ctx)->GpioReleaseInterrupt(index);
    }
    // Set GPIO polarity.
    static zx_status_t GpioSetPolarity(void* ctx, uint32_t index, gpio_polarity_t polarity) {
        return static_cast<D*>(ctx)->GpioSetPolarity(index, polarity);
    }
};

class GpioProtocolProxy {
public:
    GpioProtocolProxy() : ops_(nullptr), ctx_(nullptr) {}
    GpioProtocolProxy(const gpio_protocol_t* proto) : ops_(proto->ops), ctx_(proto->ctx) {}

    void GetProto(gpio_protocol_t* proto) {
        proto->ctx = ctx_;
        proto->ops = ops_;
    }
    bool is_valid() { return ops_ != nullptr; }
    void clear() {
        ctx_ = nullptr;
        ops_ = nullptr;
    }
    // Configures a GPIO for input.
    zx_status_t ConfigIn(uint32_t index, uint32_t flags) {
        return ops_->config_in(ctx_, index, flags);
    }
    // Configures a GPIO for output.
    zx_status_t ConfigOut(uint32_t index, uint8_t initial_value) {
        return ops_->config_out(ctx_, index, initial_value);
    }
    // Configures the GPIO pin for an alternate function (I2C, SPI, etc)
    // the interpretation of "function" is platform dependent.
    zx_status_t SetAltFunction(uint32_t index, uint64_t function) {
        return ops_->set_alt_function(ctx_, index, function);
    }
    // Reads the current value of a GPIO (0 or 1).
    zx_status_t Read(uint32_t index, uint8_t* out_value) {
        return ops_->read(ctx_, index, out_value);
    }
    // Sets the current value of the GPIO (any non-zero value maps to 1).
    zx_status_t Write(uint32_t index, uint8_t value) { return ops_->write(ctx_, index, value); }
    // Gets an interrupt object pertaining to a particular GPIO pin.
    zx_status_t GetInterrupt(uint32_t index, uint32_t flags, zx_handle_t* out_irq) {
        return ops_->get_interrupt(ctx_, index, flags, out_irq);
    }
    // Release the interrupt.
    zx_status_t ReleaseInterrupt(uint32_t index) { return ops_->release_interrupt(ctx_, index); }
    // Set GPIO polarity.
    zx_status_t SetPolarity(uint32_t index, gpio_polarity_t polarity) {
        return ops_->set_polarity(ctx_, index, polarity);
    }

private:
    gpio_protocol_ops_t* ops_;
    void* ctx_;
};

} // namespace ddk
